# üìë Chat App with Keycloak IAM

- [üìù Introduction](#-introduction)  
  - [Computer Screenshot](#computer)  
  - [Mobile Screenshot](#mobile)  
- [üîë What the App Is](#-what-the-app-is)  
- [üéØ Why It Was Developed](#-why-it-was-developed)  
- [üö´ What This App Is Not](#-what-this-app-is-not)  
- [‚öôÔ∏è Tech Stack](#Ô∏è-tech-stack)  
- [üöÄ Installation and Deployment](#-installation-and-deployment)  
  - [Prerequisites](#prerequisites)  
  - [Keycloak Setup](#keycloak-setup)  
  - [MySQL Setup](#mysql-setup)  
  - [App Setup](#app-setup)  
  - [Variable Explanation](#variable-explanation)  
  - [Running the App](#running-the-app)  
  - [Database Seeding](#database-seeding) 
- [‚ö†Ô∏è Known Limitations](#known-limitations) 
- [üîí Security Discussion](#security-discussion)  
  - [Setup](#setup)  
  - [IAM](#iam)  
  - [App Runtime](#app-runtime)  
  
# üìù Introduction

A lightweight chat application designed to demonstrate secure authentication and authorization using **Keycloak** as the Identity and Access Management (IAM) system, with **Role-Based Access Control (RBAC)** for managing user permissions.  


### Computer
<p align="center">
  <img src="repo_resources/Computer_Screen.png">
</p>

### Mobile
<p align="center">
  <img height=400 src="repo_resources/Mobile_Screen.PNG">
</p>

---

## üîë What the App Is
- **Authentication & Authorization Delegated to IAM** ‚Äì The app does not handle sign-in directly; all sign in requests are handled by the IAM. Also, the IAM defines the role of each registered user, which grants each user different access rights.
- **No Passwords Stored** ‚Äì The app does not store or manage any sensitive credentials, this is entirely delegated to the IAM.  
- **JWT-Based Security** ‚Äì After login, users receive a **JWT (JSON Web Token)** containing their **roles and permissions**. Then, the application checks the JWT for every request/action to determine whether the user should be authorized or not.
---

## üéØ Why It Was Developed
- **Part of a Multi-Phase Enterprise Security Project** ‚Äì This app is one component of a larger **Cybersecurity, Software Engineering, and DevSecOps project** that simulates a realistic enterprise environment, including IAM, secure CI/CD, centralized monitoring, secrets management, and attack simulation.   
- **Role-Based Access Control (RBAC)** ‚Äì Demonstrates how an IAM can enforce RBAC seamlessly within an application.  
- **Reference Implementation** ‚Äì Intended as a simple example for integrating apps with Keycloak IAM.  

üëâ [Learn more about the larger project here.](https://github.com/abdrnasr/Enterprise-Cybersecurity-DevSecOps-Environment-Lab)  

---

## üö´ What This App Is Not
- ‚ùå A full-fledged chat platform (no voice, video, or image sharing).  
- ‚ùå A system with private chat rooms or complex social features.  
- ‚ùå A real-time chatting app 
- ‚ùå A production-ready messaging service ‚Äî this is strictly a **demo/reference project**.  

---

## ‚öôÔ∏è Tech Stack
- **Frontend:** Next.js (React) 
- **Backend:** Node.js with Server Actions / API routes  
- **Authentication:** Keycloak (OIDC, JWT), Auth.js 
- **Database:** Minimal MySQL database to hold message and user data.

Any IAM should work as long as you can define roles for each user. However, for this project Keycloak was chosen.

---

## üöÄ Installation and Deployment
### Prerequisites
- Node.js
- Keycloak 
- MySQL (Docker)

### Keycloak Setup
For Keycloak, I already have a manually deployed Keycloak instance in my environment, which can be found [here](https://github.com/abdrnasr/Enterprise-Cybersecurity-DevSecOps-Environment-Lab/tree/main/phase2_app_iam/lab-steps-phase-2.md). You can also deploy it using docker, but this would not be covered here.

### MySQL Setup
I have provided a [docker-compose](docker-compose.yml) file that deploys the MySQL and [Adminer](https://www.adminer.org/en/).

```docker
services:
  db:
    image: mysql:9.4
    container_name: iam-mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: pass
      MYSQL_DATABASE: iam_chat
    ports:
      - "3306:3306"           # host:container
    volumes:
      - mysql_data:/var/lib/mysql
```
This will deploy a MySQL instance that can be accessed using the following connection string:
```bash
DATABASE_URL="mysql://root:pass@localhost:3306/iam_chat"
```

### App Setup
To run the app, clone the project at some path. Then, you need to create a .env file that has the following variables
```
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET="RANDOM_LONG_STRING"

KEYCLOAK_ISSUER=https://192.168.33.6/sec/realms/master
KEYCLOAK_CLIENT_ID=chat-app
KEYCLOAK_CLIENT_SECRET="Generated by keycloak"

DATABASE_NAME=iam_chat
DATABASE_URL="mysql://root:pass@localhost:3306/iam_chat"

SEEDING_SECRET="ANOTHER_LONG_SEC"
```
### Variable Explanation:
- **NEXTAUTH_URL**: The path to the base URL address to the Next.js app.
- **NEXTAUTH_SECRET**: A random secret that next-auth uses to encrypt the user access token cookie, instead of storing it as plain text in the browser.
- **KEYCLOAK_ISSUER**: The path to keycloak realm.
- **KEYCLOAK_CLIENT**: The name of the client in Keycloak that you chose.
- **KEYCLOAK_CLIENT_SECRET**: A secret generated by Keycloak to identify your client. This must be kept secret.
- **DATABASE_NAME**: The name of the database used in MySQL.
- **DATABASE_URL**: The connection string used by MySQL's client to interact with MySQL server.
- **SEEDING_SECRET**: A secret that you generate to seed the database. Without it you cannot seed the database through the web app.

### Running The App
After setting up these variables, you can now build and run the app.

```bash
# Dev Build
npm run dev

# or
# Production Build
npm run build
npm run start
```
### Database Seeding
For the app to function correctly, you need to have a database already in in MySQL. This database should be empty, and the app can construct the required tables on using the seeding endpoint. The app provides the route /api/seeding to create the database tables needed by the app. There are multiple ways to seed it.
#### Method 1:
You can seed the database by visiting the following URL and providing the SECRET as a search parameter.

http://app-host-name:3000/api/seeding?secret=SEEDING_SECRET

The **SEEDING_SECRET** is the same secret you have provided in the **.env** file. 

#### Method 2:

If you prefer to avoid passing the secret through your browser as query parameter. You can use the [seeder.py](seeder.py) script that I provided, which sends the request through python as an HTTP header (header name:).

```bash
python seeder.py localhost:3000 $SEEDING_SECRET
```

With that done, you should be able to open your browser, sign in using Keycloak, and use the app.

<a id="known-limitations"></a>

## ‚ö†Ô∏è Known Limitations
- **Base Address Change Is not Possible:** While I tried to find a way to implement it in the app, most quick plug-in authentication libraries seem to struggle with this very issue (Next-Auth, Auth.js, & Better Auth). Thus, you need to host this on the base address on a reverse proxy, or perform path truncation on the reverse proxy itself. However, given enough time, one can fully implement a full authentication solution from scratch.

<a id="security-discussion"></a>

## üîí Security Discussion
### Setup
- The setup of this app uses the best practices to secure the apps secrets. That's no code files have any secret and they should not be hard coded into code.
- Before the app can be used, you must seed the database. The seeding of the app can only be allowed to those possessing the **SEEDING_SECRET**.
- You can automate the entire deployment process using scripts, and keep all secrets secure.
### IAM
- Users credentials and roles are entirely handled by the IAM. This allows for consistent accounts across multiple services without having to manage credentials for each app. 
- Since roles are provided by the IAM, you could easily grant each user different roles without touching the application server.
### App Runtime
- All input fields were checked for Cross-Site Scripting and SQL Injection attacks.
- All SQL queries use prepared statements to protect against injection attacks.
- All insecure client data is validated at the server using [Zod](https://zod.dev/).
- Next.js provides Cross Site Request Forgery protection for server actions, so all server actions are protected from CSRF.
- Before the client can perform and action or access any protected route, the roles are checked. Different roles possess different permissions, and the permission can be assigned in the **lib/authcheck.ts** file.

```typescript
// Each role has a list of allowed permissions
const ROLE_PERMISSIONS: Record<string, readonly string[]> = {
  'chat-admin': ["post.create", "post.edit", "post.delete", "post.view"],
  'chat-editor': ["post.create", "post.edit", "post.view"],
  'chat-user': ["post.view", "post.create"],
};

// Check if a user has a ROLE with the specific permission
export function hasPermission(roles: string[], permission: string): boolean {
  return roles.some(role => ROLE_PERMISSIONS[role]?.includes(permission));
}
```
- Next-Auth protects session cookies by encryption.
- Error paths are protected with conditionals and exception handling.

